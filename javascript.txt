
Lexical Structure
	The lexical structure of a programming language is the set of elementary rules that
	specifies how you write programs in that language.

	JavaScript programs are written using the Unicode character set.

	In addition to the regular space character ( \u0020 ), JavaScript also recognizes the fol-lowing characters as whitespace: tab ( \u0009 ), vertical tab ( \u000B ), form feed( \u000C ), nonbreaking space ( \u00A0 ), byte order mark ( \uFEFF ),

Literals
	A literal is a data value that appears directly in a program.
	12
	1.2
	"hello world"
	'Hi'
	true
	false
	/javascript/gi
	null

Identifiers and Reserved Words
	An identifier is simply a name. In JavaScript, identifiers are used to name variables and functions and to provide labels for certain loops in JavaScript code. A JavaScript iden-tifier must begin with a letter, an underscore ( _ ), or a dollar sign ( $ ). Subsequent char-acters can be letters, digits, underscores, or dollar signs. (Digits are not allowed as the first character so that JavaScript can easily distinguish identifiers from numbers.)

Optional Semicolons
	In JavaScript, you can usually omit the semicolon
	between two statements if those statements are written on separate lines.

		var a
		a
		=
		3
		console.log(a)
		var a; a = 3; console.log(a);

	Note that JavaScript does not treat every line break as a semicolon: it usually treats line
	breaks as semicolons only if it can’t parse the code without the semicolons.

	if a statement begins with ( , [ , / , + , or - , there is a chance that it could be
	interpreted as a continuation of the statement before
		var y = x + f
		(a+b).toString()
		var y = x + f(a+b).toString();

	The first exception involves the return , break , and continue statements
	(see Chapter 5). These statements often stand alone, but they are sometimes followed
	by an identifier or expression. If a line break appears after any of these words (before
	any other tokens), JavaScript will always interpr
		return
		true;
		return true;

	The second exception involves the ++ and −− operators, These operators can be
	prefix operators that appear before an expression or postfix operators that appear after
	an expression. If you want to use either of these operators as postfix operators, they
	must appear on the same line as the expression they apply to.Otherwise the line break
	will be treated as a semicolon, and the ++ or -- will be parsed as a prefix operator applied
	to the code that follows. Consider this code, for example:
	x
	++
	y
	It is parsed as x; ++y; , not as x++; y .


3.Types, Values, and Variables
	Types, Values, and Variables
	Computer programs work by manipulating values, such as the number 3.14 or the text
	“Hello World.” The kinds of values that can be represented and manipulated in a
	programming language are known as types, and one of the most fundamental charac-
	teristics of a programming language is the set of types it supports.

	A variable defines a symbolic name for a value and allows the value to be
	referred to by name.

	JavaScript types can be divided into two categories: 
		primitive types 
		object types.

	JavaScript’s primitive types include numbers, strings of text (known as strings),	
	Boolean truth values (known as booleans).
	The special JavaScript values null and undefined are primitive values,

	An object (that is, a member of the type object) is a collection of properties
	where each property has a name and a value (either a primitive value, such as a number
	or string, or an object)

	Functions that are written to be used (with the new operator) to initialize a newly created
	object are known as constructors. 

	The JavaScript interpreter performs automatic garbage collection for memory manage-
	ment. 

	In JavaScript, null and undefined are the only values that methods cannot be invoked on.

	Objects and arrays are mutable: a JavaScript program can change the values of object properties and array elements. Numbers, booleans, null , and undefined are immutable

	JavaScript variables are untyped: you can assign a value of any type to a variable and
	you can later assign a value of a different type to the same variable.


	3.1 Numbers
		JavaScript represents numbers using the 64-bit floating-point format defined
		by the IEEE 754 standard, 1 which means it can represent numbers as large as
		±1.7976931348623157 × 10 308 and as small as ±5 × 10 −324 .

		A hexadecimal literal begins with “0x” or “0X”, followed by a string of hexadecimal
		digits. A hexadecimal digit is one of the digits 0 through 9 or the letters a (or A) through
		f (or F), which represent values 10 through 15.

			0xff // 15*16 + 15 = 255 (base 10)

		An octal literal begins with the digit 0 and is followed by a sequence of digits, each between 0 and 7.

		0377 // 3*64 + 7*8 + 7 = 255 (base 10)

		Arithmetic in JavaScript does not raise errors in cases of overflow, underflow, or divi-
		sion by zero. When the result of a numeric operation is larger than the largest repre-
		sentable number (overflow), the result is a special infinity value, which JavaScript prints
		as Infinity . Similarly, when a negative value becomes larger than the largest repre-
		sentable negative number, the result is negative infinity, printed as -Infinity .

		Underflow occurs when the result of a numeric operation is closer to zero than the
		smallest representable number. In this case, JavaScript returns 0. If underflow occurs
		from a negative number, JavaScript returns a special value known as “negative zero.”

		Division by zero is not an error in JavaScript: it simply returns infinity or negative
		infinity. There is one exception, however: zero divided by zero does not have a well-
		defined value, and the result of this operation is the special not-a-number value, printed
		as NaN . NaN also arises if you attempt to divide infinity by infinity, or take the square
		root of a negative number or use arithmetic operators with non-numeric operands that
		cannot be converted to numbers.

	  	Infinity 				 //A read/write variable initialized to Infinity.
		Number.POSITIVE_INFINITY //Same value, read-only.
		1/0						//This is also the same value.
		Number.MAX_VALUE + 1 	//This also evaluates to Infinity.

		Number.NEGATIVE_INFINITY // These expressions are negative infinity.
		-Infinity
		-1/0
		-Number.MAX_VALUE - 1 

		NaN 					// A read/write variable initialized to NaN.
		Number.NaN 				// A read-only property holding the same value.
		0/0 					// Evaluates to NaN.		
		
		Number.MIN_VALUE/2		// Underflow: evaluates to 0
		-Number.MIN_VALUE/2		// Negative zero
		-1/Infinity 			// Also negative 0
		-0 


		The not-a-number value has one unusual feature in JavaScript: it does not compare
		equal to any other value, including itself.

		The function isNaN() is similar. It returns true if its argument is NaN , or if that argument is a non-numeric value such as a string or an object. The related function isFinite() returns true if its argument is a number other than NaN , Infinity , or - Infinity .

	3.2 Text
		In ECMAScript 3, string literals must be written on a single line. In ECMAScript 5,
		however, you can break a string literal across multiple lines by ending each line but the
		last with a backslash ( \ ).

		"two\nlines"		// A string representing 2 lines written on one line
		"one\				// A one-line string written on 3 lines. ECMAScript 5 only.
		long\
		line"

		Escape Sequences in String Literals
			Sequence Character represented
			\0 The NUL character ( \u0000 )
			\b Backspace ( \u0008 )
			\t Horizontal tab ( \u0009 )
			\n Newline ( \u000A )
			\v Vertical tab ( \u000B )
			\f Form feed ( \u000C )
			\r Carriage return ( \u000D )
			\" Double quote ( \u0022 )
			\' Apostrophe or single quote ( \u0027 )
			\\ Backslash ( \u005C )
			\x XX The Latin-1 character specified by the two hexadecimal digits XX
			\u XXXX The Unicode character specified by the four hexadecimal digits XXXX

	3.3 Boolean Values
		The following values convert to, and therefore work like, false :
			undefined
			null
			0
			-0
			NaN
			"" // the empty string

	3.4 null and undefined
		typeof operator on null returns the string “object”, indicating that null can be thought of as a special object value that indicates “no object”.

		undefined is a predefined global variable (not a language keyword like null ) that
		is initialized to the undefined value.

		The equality operator == considers them to be equal.
		(Use the strict equality operator === to distinguish them.) Both are falsy values—they
		behave like false when a boolean value is required. Neither null nor undefined have
		any properties or methods. In fact, using . or [] to acces a property or method of these
		values causes a TypeError.

	3.5 The Global Object
		The global object is a regular JavaScript object that serves a very important purpose: the properties of this object are the globally defined symbols that are available to a JavaScript program.

		• global properties like undefined , Infinity , and NaN
		• global functions like isNaN() , parseInt() (§3.8.2), and eval() (§4.12).
		• constructor functions like Date() , RegExp() , String() , Object() , and Array()
		(§3.8.2)
		• global objects like Math and JSON (§6.9)

		This global Window object has a self-referential window property that can be used instead of this to refer to the global object.

	3.6 Wrapper Objects
		When the value of a property is a function, we call it a method

		var s = "test";		// Start with a string value.
		s.len = 4;			// Set a property on it.
		var t = s.len;		// Now query the property.

		When you run this code, the value of t is undefined . The second line of code creates a
		temporary String object, sets its len property to 4, and then discards that object. The
		third line creates a new String object from the original (unmodified) string value and
		then tries to read the len property. This property does not exist, and the expression
		evaluates to undefined. 

		This code demonstrates that strings, numbers, and boolean
		values behave like objects when you try to read the value of a property (or method)
		from them. But if you attempt to set the value of a property, that attempt is silently
		ignored: the change is made on a temporary object and does not persist.
		The temporary objects created when you access a property of a string, number, or
		boolean are known as wrapper objects,

		Note that it is possible (but almost never necessary or useful) to explicitly create wrap-
		per objects, by invoking the String() , Number() , or Boolean() constructors:

		var s = new String(s); //  A string object

	3.7 Immutable Primitive Values and Mutable Object References
		object values are references, and we say that
		objects are compared by reference: two object values are the same if and only if they
		refer to the same underlying object.

	3.8 Type Conversions
		Value 		Converted to:	 String 	Number Boolean Object
		undefined 	"undefined" NaN false throws TypeError
		null 		"null" 0 false throws TypeError
		true 		"true" 1 new Boolean(true)
		false 		"false" 0 new Boolean(false)
		"" 			(empty string) 0 false new String("")
		"1.2" 		(nonempty, numeric) 1.2 true new String("1.2")
		"one" 		(nonempty, non-numeric) NaN true new String("one")
		0 "0" 		false new Number(0)
		-0 "0" 		false new Number(-0)
		NaN 		"NaN" false new Number(NaN)
		Infinity 	"Infinity" true new Number(Infinity)
		-Infinity 	"-Infinity" true new Number(-Infinity)
		1 (finite, non-zero) 	"1" true new Number(1)
		{} (any object) see §3.8.3 see §3.8.3 true 
		[] (empty array) "" 0 true 
		[9] (1 numeric elt) "9" 9 true 
		['a'] (any other array) use join() method NaN true 
		function(){} (any function) see §3.8.3 NaN true

		null == undefined 	//These two values are treated as equal.
		"0" == 0			//String converts to a number before comparing.
		0 == false 			//Boolean converts to number before comparing.
		"0" == false 		//Both operands convert to numbers before comparing.

		Explicit type conversion
			Explicit type conversion is to use the Boolean() ,
			Number() , String() , or Object() functions.
				Number("3")			//3
				String(false)		//"false" Or use false.toString()
				Boolean([])			//true
				Object(3) 			//new Number(3)

				var n = 17;
				binary_string = n.toString(2);		// Evaluates to "10001"
				octal_string = "0" + n.toString(8);	// Evaluates to "021"
				hex_string = "0x" + n.toString(16);	// Evaluates to "0x11"

				toFixed() 
					converts a number to a string with a specified number
				of digits after the decimal point. It never uses exponential notation. 

				toExponential()
					converts a number to a string using exponential notation, with one digit before the
				decimal point and a specified number of digits after the decimal point (which means
				that the number of significant digits is one larger than the value you specify). 
				
				toPrecision() 
					converts a number to a string with the number of significant digits you specify.
				It uses exponential notation if the number of significant digits is not large enough to
				display the entire integer portion of the number. Note that all three methods round the
				trailing digits or pad with zeros as appropriate. 

				var n = 123456.789;
				n.toFixed(0);		"123457"
				n.toFixed(2);		"123456.79"
				n.toFixed(5);		"123456.78900"
				n.toExponential(1);	"1.2e+5"
				n.toExponential(3);	"1.235e+5"
				n.toPrecision(4);	"1.235e+5"
				n.toPrecision(7);	"123456.8"
				n.toPrecision(10);	"123456.7890"

				The parseInt() and parseFloat() functions (these are global functions, not methods of any class) aremore flexible. parseInt() parses only integers, while parseFloat() parses both integers and floating-point numbers. If a string begins with “0x” or “0X”, parseInt() interprets it as a hexadecimal number. 

				Both parseInt() and parseFloat() skip leading white-space, parse as many numeric characters as they can, and ignore anything that follows.If the first nonspace character is not part of a valid numeric literal, they return NaN:

				parseInt("3 blind mice")		//3
				parseFloat(" 3.14 meters")		//3.14
				parseInt("-12.34")				//-12
				parseInt("0xFF")				//255
				parseInt("0xff")				//255
				parseInt("-0XFF")				//-255
				parseFloat(".1")				//0.1				
				parseInt("0.1")					//0			
				parseInt(".1")					//NaN: integers can't start with "."
				parseFloat("$72.47");			//NaN: numbers can't start with "$"
				
				
				parseInt() accepts an optional second argument specifying the radix (base) of the
				number to be parsed. Legal values are between 2 and 36. For example:

				parseInt("11", 2);				//3 (1*2 + 1)
				parseInt("ff", 16);				//255 (15*16 + 15)
				parseInt("zz", 36);				//1295 (35*36 + 35)
				parseInt("077", 8);				//63 (7*8 + 7)
				parseInt("077", 10);			//77 (7*10 + 7)

		Object to Primitive Conversions
			The toString()
				method of the Array class, for example, converts each array element to a string and
				joins the resulting strings together with commas in between. The toString() method
				of the Function class returns an implementation-defined representation of a function.
				In practice, implementations usually convert user-defined functions to strings of Java-
				Script source code. The Date class defines a toString() method that returns a human-
				readable (and JavaScript-parsable) date and time string. The RegExp class defines a
				toString() method that converts RegExp objects to a string that looks like a RegExp

			
				[1,2,3].toString()					//"1,2,3"
				
				(function(x) { f(x); }).toString() 	// "function(x) {\n
														f(x);\n}"
													
				/\d+/g.toString()					//"/\\d+/g"

				new Date(2010,0,1).toString() 		//Jan 01 2010 00:00:00 GMT-0800 (PST)"
			valueOf()
				The other object conversion function is called valueOf() . The job of this method is lesswell-defined: it is supposed to convert an object to a primitive value that represents the object, if any such primitive value exists.

	3.10 Function Scope and Hoisting
		JavaScript’s function scope means that all variables declared within a function are visi-
		ble throughout the body of the function. Curiously, this means that variables are even
		visible before they are declared. This feature of JavaScript is informally known as hoist-
		ing:

		Variables As Properties
			When you declare a global JavaScript variable, what you are actually doing is defining
			a property of the global object (§3.5). If you use var to declare the variable, the property
			that is created is nonconfigurable (see §6.7), which means that it cannot be deleted
			with the delete operator.

			var truevar = 1;		//A properly declared global variable, nondeletable.
			fakevar = 2;			//Creates a deletable property of the global object.
			this.fakevar2 = 3;		//This does the same thing.
			delete truevar			//false: variable not deleted
			delete fakevar 			//true: variable deleted
			delete this.fakevar2 	//true: variable deleted

		The Scope Chain
			the scope chain consists of two objects. The first is the object that defines the function’s
			parameters and local variables, and the second is the global object.

Expressions and Operators
	An expression is a phrase of JavaScript that a JavaScript interpreter can evaluate to
	produce a value.

	4.1 Primary Expressions
		Primary expressions in JavaScript are constant or literal values, certain language keywords, and variable reference.

		Literals are constant values that are embedded directly in your program.
			1.23		// A number literal
			"hello"		// A string literal
			/pattern/	// A regular expression literal

		Some of JavaScript’s reserved words are primary expressions:
			true 		// Evalutes to the boolean true value
			false 		// Evaluates to the boolean false value
			null 		// Evaluates to the null value
			this 		// Evaluates to the "current" object

		the third type of primary expression is the bare variable reference:
			i 			// Evaluates to the value of the variable i.
			sum 		// Evaluates to the value of the variable sum.
			undefined	// undefined is a global variable, not a keyword like null.

	4.4 Property Access Expressions
		JavaScript defines two syntaxes for property access:
			expression . identifier
			expression [ expression ]

		With either type of property access expression, the expression before the . or [ is first
		evaluated. If the value is null or undefined , the expression throws a TypeError, since
		these are the two JavaScript values that cannot have properties.

		f(0) // f is the function expression; 0 is the argument expression.

	4.6 Object Creation Expressions
		new Object()
		new Point(2,3)

		new Object
		new Date

		When an object creation expression is evaluated, JavaScript first creates a new empty
		object, just like the one created by the object initializer {} . Next, it invokes the specified
		function with the specified arguments, passing the new object as the value of the
		this keyword.

		If a constructor does return an object value, that value becomes the value of the object
		creation expression and the newly created object is discarded.

	4.7 Operator Overview
		Lvalues
			lvalue is a historical term that means “an
			expression that can legally appear on the left side of an assignment expression.” In
			JavaScript, variables, properties of objects, and elements of arrays are lvalues.

		Operator Side Effects
			The delete operator also has side effects: deleting a property is like (but not the same as) assigning undefined to the property

	4.12 Evaluation Expressions
		JavaScript has the ability to interpret strings of Java-
		Script source code, evaluating them to produce a value. JavaScript does this with the
		global function eval() :

		eval("3+2")		//  5

		eval()
			eval() expects one argument. If you pass any value other than a string, it simply returns
			that value. If you pass a string, it attempts to parse the string as JavaScript code, throw-
			ing a SyntaxError if it fails. If it successfully parses the string, then it evaluates the code	and returns the value of the last expression or statement in the string or undefined if
			the last expression or statement had no value.

			The key thing about eval() (when invoked like this) is that it uses the variable envi-
			ronment of the code that calls it. That is, it looks up the values of variables and defines
			new variables and functions in the same way that local code does. If a function defines
			a local variable x and then calls eval("x") , it will obtain the value of the local variable.
			If it calls eval("x=1") , it changes the value of the local variable. And if the function calls
			eval("var y = 3;") , it has declared a new local variable y . Similarly a function can
			declare a local function with code like this:

			eval("function f() { return x+1; }");

			If the eval() function was invoked by any name other than “eval”, it was allowed to throw an EvalError.

		Global eval()
			Direct calls to eval() use the variable environment of the calling context. Any other call—an indirect call—uses the global object as its variable environment and cannot read, write,or define local variables or functions.


			Before IE9, IE differs from other browsers: it does not do a global eval when eval() is
			invoked by a different name. (It doesn’t throw an EvalError either: it simply does a local
			eval.) But IE does define a global function named execScript() that executes its string
			argument as if it were a top-level script. (Unlike eval() , however, execScript() always
			returns null .)

		Strict eval()
			“use strict” directive, then eval() does a local eval with a private variable environment.
			This means that in strict mode, evaluated code can query and set local variables, but it
			cannot define new variables or functions in the local scope.

			Furthermore, strict mode makes eval() even more operator-like by effectively making
			“eval” into a reserved word. You are not allowed to overwrite the eval() function with
			a new value. And you are not allowed to declare a variable, function, function param-
			eter, or catch block parameter with the name “eval”.

	4.13  Miscellaneous Operators
		typeof Operator
			x 								typeof x
			-------------------------------------------
			undefined 						"undefined"
			null 							"object"
			true or false 					"boolean"
			any number or NaN 				"number"
			any string 						"string"		
			any function 					"function"
			any nonfunction native object 	"object"
			any host object 				An implementation-defined string, 
											but not “undefined”, “boolean”,
											“number”, or “string”.

		The delete Operator
			delete is a unary operator that attempts to delete the object property or array element
			specified as its operand.

			var o = { x: 1, y: 2}; 	// Start with an object
			delete o.x;				// Delete one of its properties
			"x" in o				// false: the property does not exist anymore
			var a = [1,2,3];		// Start with an array
			delete a[2];			// Delete the last element of the array
			a.length				// => 2: array only has two elements now

			Note that a deleted property or array element is not merely set to the undefined value.
			When a property is deleted, the property ceases to exist. Attempting to read a non-
			existent property returns undefined ,

			delete expects its operand to be an lvalue. If it is not an lvalue, the operator takes no
			action and returns true . Otherwise, delete attempts to delete the specified lvalue.
			delete returns true if it successfully deletes the specified lvalue.

Statements
	statements are JavaScript sentences or commands

	Expressions are evaluated to produce a value, but statements are executed to make something happen.

	JavaScript has a number of statements or control structures that do just this:
		• Conditionals are statements like if and switch that make the JavaScript interpreter
		execute or skip other statements depending on the value of an expression.

		• Loops are statements like while and for that execute other statements repetitively.

		• Jumps are statements like break , return , and throw that cause the interpreter to
		jump to another part of the program.

	5.1 Expression Statements
		Assignment statements are one major category of expression statements. For ex
			greeting = "Hello " + name;
			i *= 3;

	5.2 Compound and Empty Statements
		Just as the comma operator combines multiple expressions into a single
		expression, a statement block combines multiple statements into a single compound
		statement

			{
				x = Math.PI;
				cx = Math.cos(x);
				console.log("cos(π) = " + cx);
			}

		The empty statement is the opposite: it allows you to include
		no statements where one is expected. The empty statement looks like this:
		;

		The JavaScript interpreter takes no action when it executes an empty statement. The
		empty statement is occasionally useful when you want to create a loop that has an
		empty body. Consider the following for loop:

			// Initialize an array a
			for(i = 0; i < a.length; a[i++] = 0) ;

			if ((a == 0) || (b == 0));	// Oops! This line does nothing...
			o = null;					// and this line is always executed.

	5.3 Declaration Statements
		The var and function are declaration statements—they declare or define variables and
		functions.

		5.3.1 var
			If a var statement appears within the body of a function, it defines local variables,
			scoped to that function. When var is used in top-level code, it declares global variables,
			visible throughout the JavaScript program. As noted in §3.10.2, global variables are
			properties of the global object. Unlike other global properties, however, properties
			created with var cannot be deleted.

		5.3.2 function
			We can invoke a Java-Script function before you declare it.

			Like the var statement, function declaration statements create variables that cannot be
			deleted. These variables are not read-only, however, and their value can be overwritten.

	5.4 Conditional Statements
		5.4.1 if
			// If username is null, undefined, false, 0, "", or NaN, give it a new value
			if (!username) username = "John Doe";

		5.4.2 else if
			when you need to execute one of many pieces of code? One way to do this is with an else if statement. 

			else if is not really a JavaScript statement, but simply a frequently used programming idiom that results when repeated if/else statements are used

		5.4.3 switch
			An if statement causes a branch in the flow of a program’s execution, and you can use
			the else if idiom to perform a multiway branch. This is not the best solution, however,
			when all of the branches depend on the value of the same expression. In this case, it is
			wasteful to repeatedly evaluate that expression in multiple if statements.

			The switch statement handles exactly this situation. The switch keyword is followed
			by an expression in parentheses and a block of code in curly braces:

			switch(expression) {
				statements
			}

			When using switch inside a function, however, you may
			use a return statement instead of a break statement. Both serve to terminate the
			switch statement and prevent execution from falling through to the next case .

			function convert(x) {
				switch(typeof x) {
					case 'number':
						return x.toString(16);
					case 'string':
						return '"' + x + '"';
					default:
						return String(x);
				}
			}

			The matching case is determined using the === identity operator, not the == equality operator, so the expressions must match without any type conversion.

			Note that in the examples above, the default: label appears at the end of the switch body, following all the case labels. This is a logical and common place for it, but it can actually appear	anywhere within the body of the statement.

	5.5 Loops
		JavaScript has four looping statements: while , do/while , for , and for/in .

		5.5.3 do/while
			First, the do loop requires both the do keyword (to mark the beginning of
			the loop) and the while keyword (to mark the end and introduce the loop condition).
			Also, the do loop must always be terminated with a semicolon. The while loop doesn’t
			need a semicolon if the loop body is enclosed in curly braces.

		5.5.3 for
			initialize , test , and increment are three expressions (separated by semicolons) that
			are responsible for initializing, testing, and incrementing the loop variable.

			function tail(o) {
				// Return the tail of linked list o
				for(; o.next; o = o.next) /* empty */ ; // Traverse while o.next is truthy
				return o;
			}

			Note that the code above has no initialize expression. Any of the three expressions
			may be omitted from a for loop, but the two semicolons are required. If you omit the
			test expression, the loop repeats forever, and for(;;) is another way of writing an
			infinite loop, like while(true) .

		5.5.4 for/in
			To execute a for/in statement, the JavaScript interpreter first evaluates the object ex-
			pression. If it evaluates to null or undefined , the interpreter skips the loop and moves
			on to the next statement. 3 If the expression evaluates to a primitive value, that value is
			converted to its equivalent wrapper object (§3.6). Otherwise, the expression is already
			an object. The interpreter now executes the body of the loop once for each enumerable
			property of the object.

	5.6 Jumps
		Another category of JavaScript statements are jump statements. As the name implies,
		these cause the JavaScript interpreter to jump to a new location in the source code. The
		break statement makes the interpreter jump to the end of a loop or other statement.
		continue makes the interpreter skip the rest of the body of a loop and jump back to the
		top of a loop to begin a new iteration.

		5.6.1 Labeled Statements
			break and continue are theonly JavaScript statements that use statement labels

			mainloop: while(token != null) {
				// Code omitted...
				continue mainloop; // Jump to the next iteration of the named loop
				// More code omitted...
			}
			The namespace for labels is different than the namespace for variables and functions, so you can use the same identifier as a statement label and as a variable or function name. Statement labels are defined only within the statement to	which they apply (and within its substatements, of course). A statement may not have the same label as a statement that contains it, but two statements may have the same label as long as neither one is nested within the other. Labeled statements may them-	selves be labeled. Effectively, this means that any statement may have multiple labels.

		5.6.2 break
			A newline is not allowed between the break keyword and the labelname . This is a result
			of JavaScript’s automatic insertion of omitted semicolons: if you put a line terminator
			between the break keyword and the label that follows, JavaScript assumes you meant
			to use the simple, unlabeled form of the statement and treats the line terminator as a
			semicolon.

		5.6.3 continue
			The continue statement, in both its labeled and unlabeled forms, can be used only
			within the body of a loop. Using it anywhere else causes a syntax error.

			• In a while loop, the specified expression at the beginning of the loop is tested again,
			and if it’s true , the loop body is executed starting from the top.

			• In a do/while loop, execution skips to the bottom of the loop, where the loop
			condition is tested again before restarting the loop at the top.

			• In a for loop, the increment expression is evaluated, and the test expression is
			tested again to determine if another iteration should be done.

			• In a for/in loop, the loop starts over with the next property name being assigned
			to the specified variable.

		5.6.4 return
			A return statement may appear only within the body of a function. It is a syntax error
			for it to appear anywhere else.

			The return statement can also be used without an expression to make the function
			return undefined to its caller.

		5.6.5 throw
			An Error object has a name property that specifies	the type of error and a message property that holds the string passed to the constructor function (see the Error class in the reference section).

			If no exception handler is ever found, the exception is treated as an error and is reported to the user.

		5.6.6 try/catch/finally
			Both the catch and finally blocks are optional, but a try block must be accompanied by at least one of these blocks.
			
			If an exception occurs in the try block and there is an associated catch block to handle
			the exception, the interpreter first executes the catch block and then the finally block.
			If there is no local catch block to handle the exception, the interpreter first executes
			the finally block and then jumps to the nearest containing catch clause.
			
			If a finally block itself causes a jump with a return , continue , break , or throw statement,
			or by calling a method that throws an exception, the interpreter abandons whatever
			jump was pending and performs the new jump.
			
			try and finally can be used together without a catch clause.

	5.7 Miscellaneous Statements
		This section describes the remaining three JavaScript statements— with , debugger , and
		use strict .

		5.7.1 with
			The with statement is used to temporarily extendthe scope chain. It has the following syntax:

			with (object)
				statement

			The common use of the with statement is to make it easier to work with deeply nested
			object hierarchies

			document.forms[0].address.value

			If you need to write expressions like this a number of times, you can use the with
			statement to add the form object to the scope chain:
			
			with(document.forms[0]) {
				// Access form elements directly here. For example:
				name.value = "";
				address.value = "";
				email.value = "";
			}

			with(o) x = 1;
			If the object o has a property x , then this code assigns the value 1 to that property. But
			if x is not defined in o , this code is the same as x = 1 without the with statement. It
			assigns to a local or global variable named x , or creates a new property of the global
			object. A with statement provides a shortcut for reading properties of o , but not for
			creating new properties of o .

		5.7.2 debugger
			debugger statement acts like a breakpoint: exe-cution of JavaScript code stops and you can use the debugger to print variables’ values,examine the call stack, and so on

		5.7.3 “use strict”
			"use strict" is a directive introduced in ECMAScript 5.


			

			
			
			
			



			
			
			


		
		
		
				
				
				
			
			
						
			
			


			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
		
		
		
		

		




	



























Function
	All functions return a value in JavaScript. In the absence of an explicit return statement, a function returns undefined.

Immediately Executing Function
	You can execute a function immediately after you define it. Simply wrap the function in parentheses () and invoke it,

	(function foo() {
		console.log('foo was executed!');
	})();

	The reason for having an immediately executing function is to create a new variable scope. An if, else, or while does not create a new variable scope in JavaScript.

Anonymous Function
	A function without a name is called an anonymous function. In JavaScript, you can assign a function to a variable.
	If you are going to use a function as a variable, you don’t need to name the function.

	var foo1 = function namedFunction() { 
		// no use of name, just wasted characters
		console.log('foo1');
	}
	foo1(); // foo1
 
	var foo2 = function () {
		// no function name given i.e. anonymous function
		console.log('foo2');
	}
	foo2(); // foo2

first-class functions
	A programming language is said to have first-class functions if a function can be treated the same way as any other
	variable in the language. JavaScript has first-class functions.

Higher-Order Functions
	Functions that take functions as arguments are called higher-order functions.

	setTimeout(function () {
		console.log('2000 milliseconds have passed since this demo started');
	}, 2000);

Closures
	Whenever we have a function defined inside another function, the inner function has access to the variables declared
	in the outer function.




Module In Node.js
	File-Based Module System
		• Each file is its own module.
		• Each file has access to the current module definition using the module variable.
		• The export of the current module is determined by the module.exports variable.
		• To import a module, use the globally available require function.
	Core Module
		path,fs,os,util,

	external node_modules

node.js module system (CommonJS) Approach
	var foo = require('./foo');
	var bar = require('./bar');
	// continue code here

Browser module system (AMD-async module defination) Approach
	define(['./foo', './bar'], function(foo, bar){
		// continue code here
	});
	third party RequireJS needed

Globals
	true globals (shared between all modules) 
		ex: require,console__dirname__filenameprocessBufferglobal

	local globals (variables specific to the current module).
		ex: module and exports.


A few points to keep in mind when working with async functions based
on callbacks are the following:
1. Never call the callback twice.
2. Never throw an error.

client-side XHRs (XMLHttpRequest)
XMLHttpRequest (XHR) is a global class available in all modern browsers that allows you to make HTTP requests
using JavaScript. The name is XMLHttpRequest to ensure that all browsers follow the same name for this class. The name
has XML in it because that was the original intended data format for making HTTP requests, but it is not relevant anymore
as it can be used to make HTTP requests in any format. In fact, most people just use the JSON format now.

The View handles the visual part,
taking care of user interaction. The Controller responds to system and user events,
commanding the Model and View to change appropriately. The Model handles data
manipulation, responding to requests for information or changing its state according
to the Controller's instructions.

thread & process
http://www.cs.ucsb.edu/~rich/class/cs170/notes/IntroThreads/


websocket
https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications

http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-node-js

"It is impossible for a distributed computer system to simultaneously provide all three of the
following guarantees: Consistency, Availability, and Partition tolerance."

mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092