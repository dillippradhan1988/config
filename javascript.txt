
Lexical Structure
	The lexical structure of a programming language is the set of elementary rules that
	specifies how you write programs in that language.

	JavaScript programs are written using the Unicode character set.

	In addition to the regular space character ( \u0020 ), JavaScript also recognizes the fol-lowing characters as whitespace: tab ( \u0009 ), vertical tab ( \u000B ), form feed( \u000C ), nonbreaking space ( \u00A0 ), byte order mark ( \uFEFF ),

Literals
	A literal is a data value that appears directly in a program.
	12
	1.2
	"hello world"
	'Hi'
	true
	false
	/javascript/gi
	null

Identifiers and Reserved Words
	An identifier is simply a name. In JavaScript, identifiers are used to name variables and functions and to provide labels for certain loops in JavaScript code. A JavaScript iden-tifier must begin with a letter, an underscore ( _ ), or a dollar sign ( $ ). Subsequent char-acters can be letters, digits, underscores, or dollar signs. (Digits are not allowed as the first character so that JavaScript can easily distinguish identifiers from numbers.)

Optional Semicolons
	In JavaScript, you can usually omit the semicolon
	between two statements if those statements are written on separate lines.

		var a
		a
		=
		3
		console.log(a)
		var a; a = 3; console.log(a);

	Note that JavaScript does not treat every line break as a semicolon: it usually treats line
	breaks as semicolons only if it can’t parse the code without the semicolons.

	if a statement begins with ( , [ , / , + , or - , there is a chance that it could be
	interpreted as a continuation of the statement before
		var y = x + f
		(a+b).toString()
		var y = x + f(a+b).toString();

	The first exception involves the return , break , and continue statements
	(see Chapter 5). These statements often stand alone, but they are sometimes followed
	by an identifier or expression. If a line break appears after any of these words (before
	any other tokens), JavaScript will always interpr
		return
		true;
		return true;

	The second exception involves the ++ and −− operators, These operators can be
	prefix operators that appear before an expression or postfix operators that appear after
	an expression. If you want to use either of these operators as postfix operators, they
	must appear on the same line as the expression they apply to.Otherwise the line break
	will be treated as a semicolon, and the ++ or -- will be parsed as a prefix operator applied
	to the code that follows. Consider this code, for example:
	x
	++
	y
	It is parsed as x; ++y; , not as x++; y .


3.Types, Values, and Variables
	Types, Values, and Variables
	Computer programs work by manipulating values, such as the number 3.14 or the text
	“Hello World.” The kinds of values that can be represented and manipulated in a
	programming language are known as types, and one of the most fundamental charac-
	teristics of a programming language is the set of types it supports.

	A variable defines a symbolic name for a value and allows the value to be
	referred to by name.

	JavaScript types can be divided into two categories: 
		primitive types 
		object types.

	JavaScript’s primitive types include numbers, strings of text (known as strings),	
	Boolean truth values (known as booleans).
	The special JavaScript values null and undefined are primitive values,

	An object (that is, a member of the type object) is a collection of properties
	where each property has a name and a value (either a primitive value, such as a number
	or string, or an object)

	Functions that are written to be used (with the new operator) to initialize a newly created
	object are known as constructors. 

	The JavaScript interpreter performs automatic garbage collection for memory manage-
	ment. 

	In JavaScript, null and undefined are the only values that methods cannot be invoked on.

	Objects and arrays are mutable: a JavaScript program can change the values of object properties and array elements. Numbers, booleans, null , and undefined are immutable

	JavaScript variables are untyped: you can assign a value of any type to a variable and
	you can later assign a value of a different type to the same variable.


	3.1 Numbers
		JavaScript represents numbers using the 64-bit floating-point format defined
		by the IEEE 754 standard, 1 which means it can represent numbers as large as
		±1.7976931348623157 × 10 308 and as small as ±5 × 10 −324 .

		A hexadecimal literal begins with “0x” or “0X”, followed by a string of hexadecimal
		digits. A hexadecimal digit is one of the digits 0 through 9 or the letters a (or A) through
		f (or F), which represent values 10 through 15.

			0xff // 15*16 + 15 = 255 (base 10)

		An octal literal begins with the digit 0 and is followed by a sequence of digits, each between 0 and 7.

		0377 // 3*64 + 7*8 + 7 = 255 (base 10)

		Arithmetic in JavaScript does not raise errors in cases of overflow, underflow, or divi-
		sion by zero. When the result of a numeric operation is larger than the largest repre-
		sentable number (overflow), the result is a special infinity value, which JavaScript prints
		as Infinity . Similarly, when a negative value becomes larger than the largest repre-
		sentable negative number, the result is negative infinity, printed as -Infinity .

		Underflow occurs when the result of a numeric operation is closer to zero than the
		smallest representable number. In this case, JavaScript returns 0. If underflow occurs
		from a negative number, JavaScript returns a special value known as “negative zero.”

		Division by zero is not an error in JavaScript: it simply returns infinity or negative
		infinity. There is one exception, however: zero divided by zero does not have a well-
		defined value, and the result of this operation is the special not-a-number value, printed
		as NaN . NaN also arises if you attempt to divide infinity by infinity, or take the square
		root of a negative number or use arithmetic operators with non-numeric operands that
		cannot be converted to numbers.

	  	Infinity 				 //A read/write variable initialized to Infinity.
		Number.POSITIVE_INFINITY //Same value, read-only.
		1/0						//This is also the same value.
		Number.MAX_VALUE + 1 	//This also evaluates to Infinity.

		Number.NEGATIVE_INFINITY // These expressions are negative infinity.
		-Infinity
		-1/0
		-Number.MAX_VALUE - 1 

		NaN 					// A read/write variable initialized to NaN.
		Number.NaN 				// A read-only property holding the same value.
		0/0 					// Evaluates to NaN.		
		
		Number.MIN_VALUE/2		// Underflow: evaluates to 0
		-Number.MIN_VALUE/2		// Negative zero
		-1/Infinity 			// Also negative 0
		-0 


		The not-a-number value has one unusual feature in JavaScript: it does not compare
		equal to any other value, including itself.

		The function isNaN() is similar. It returns true if its argument is NaN , or if that argument is a non-numeric value such as a string or an object. The related function isFinite() returns true if its argument is a number other than NaN , Infinity , or - Infinity .

	3.2 Text
		In ECMAScript 3, string literals must be written on a single line. In ECMAScript 5,
		however, you can break a string literal across multiple lines by ending each line but the
		last with a backslash ( \ ).

		"two\nlines"		// A string representing 2 lines written on one line
		"one\				// A one-line string written on 3 lines. ECMAScript 5 only.
		long\
		line"

		Escape Sequences in String Literals
			Sequence Character represented
			\0 The NUL character ( \u0000 )
			\b Backspace ( \u0008 )
			\t Horizontal tab ( \u0009 )
			\n Newline ( \u000A )
			\v Vertical tab ( \u000B )
			\f Form feed ( \u000C )
			\r Carriage return ( \u000D )
			\" Double quote ( \u0022 )
			\' Apostrophe or single quote ( \u0027 )
			\\ Backslash ( \u005C )
			\x XX The Latin-1 character specified by the two hexadecimal digits XX
			\u XXXX The Unicode character specified by the four hexadecimal digits XXXX

	3.3 Boolean Values
		The following values convert to, and therefore work like, false :
			undefined
			null
			0
			-0
			NaN
			"" // the empty string

	3.4 null and undefined
		typeof operator on null returns the string “object”, indicating that null can be thought of as a special object value that indicates “no object”.

		undefined is a predefined global variable (not a language keyword like null ) that
		is initialized to the undefined value.

		The equality operator == considers them to be equal.
		(Use the strict equality operator === to distinguish them.) Both are falsy values—they
		behave like false when a boolean value is required. Neither null nor undefined have
		any properties or methods. In fact, using . or [] to acces a property or method of these
		values causes a TypeError.

	3.5 The Global Object
		The global object is a regular JavaScript object that serves a very important purpose: the properties of this object are the globally defined symbols that are available to a JavaScript program.

		• global properties like undefined , Infinity , and NaN
		• global functions like isNaN() , parseInt() (§3.8.2), and eval() (§4.12).
		• constructor functions like Date() , RegExp() , String() , Object() , and Array()
		(§3.8.2)
		• global objects like Math and JSON (§6.9)

		This global Window object has a self-referential window property that can be used instead of this to refer to the global object.

	3.6 Wrapper Objects
		When the value of a property is a function, we call it a method

		var s = "test";		// Start with a string value.
		s.len = 4;			// Set a property on it.
		var t = s.len;		// Now query the property.

		When you run this code, the value of t is undefined . The second line of code creates a
		temporary String object, sets its len property to 4, and then discards that object. The
		third line creates a new String object from the original (unmodified) string value and
		then tries to read the len property. This property does not exist, and the expression
		evaluates to undefined. 

		This code demonstrates that strings, numbers, and boolean
		values behave like objects when you try to read the value of a property (or method)
		from them. But if you attempt to set the value of a property, that attempt is silently
		ignored: the change is made on a temporary object and does not persist.
		The temporary objects created when you access a property of a string, number, or
		boolean are known as wrapper objects,

		Note that it is possible (but almost never necessary or useful) to explicitly create wrap-
		per objects, by invoking the String() , Number() , or Boolean() constructors:

		var s = new String(s); //  A string object

	3.7 Immutable Primitive Values and Mutable Object References
		object values are references, and we say that
		objects are compared by reference: two object values are the same if and only if they
		refer to the same underlying object.

	3.8 Type Conversions
		Value 		Converted to:	 String 	Number Boolean Object
		undefined 	"undefined" NaN false throws TypeError
		null 		"null" 0 false throws TypeError
		true 		"true" 1 new Boolean(true)
		false 		"false" 0 new Boolean(false)
		"" 			(empty string) 0 false new String("")
		"1.2" 		(nonempty, numeric) 1.2 true new String("1.2")
		"one" 		(nonempty, non-numeric) NaN true new String("one")
		0 "0" 		false new Number(0)
		-0 "0" 		false new Number(-0)
		NaN 		"NaN" false new Number(NaN)
		Infinity 	"Infinity" true new Number(Infinity)
		-Infinity 	"-Infinity" true new Number(-Infinity)
		1 (finite, non-zero) 	"1" true new Number(1)
		{} (any object) see §3.8.3 see §3.8.3 true 
		[] (empty array) "" 0 true 
		[9] (1 numeric elt) "9" 9 true 
		['a'] (any other array) use join() method NaN true 
		function(){} (any function) see §3.8.3 NaN true

		null == undefined 	//These two values are treated as equal.
		"0" == 0			//String converts to a number before comparing.
		0 == false 			//Boolean converts to number before comparing.
		"0" == false 		//Both operands convert to numbers before comparing.

		Explicit type conversion
			Explicit type conversion is to use the Boolean() ,
			Number() , String() , or Object() functions.
				Number("3")			//3
				String(false)		//"false" Or use false.toString()
				Boolean([])			//true
				Object(3) 			//new Number(3)

				var n = 17;
				binary_string = n.toString(2);		// Evaluates to "10001"
				octal_string = "0" + n.toString(8);	// Evaluates to "021"
				hex_string = "0x" + n.toString(16);	// Evaluates to "0x11"

				toFixed() 
					converts a number to a string with a specified number
				of digits after the decimal point. It never uses exponential notation. 

				toExponential()
					converts a number to a string using exponential notation, with one digit before the
				decimal point and a specified number of digits after the decimal point (which means
				that the number of significant digits is one larger than the value you specify). 
				
				toPrecision() 
					converts a number to a string with the number of significant digits you specify.
				It uses exponential notation if the number of significant digits is not large enough to
				display the entire integer portion of the number. Note that all three methods round the
				trailing digits or pad with zeros as appropriate. 

				var n = 123456.789;
				n.toFixed(0);		"123457"
				n.toFixed(2);		"123456.79"
				n.toFixed(5);		"123456.78900"
				n.toExponential(1);	"1.2e+5"
				n.toExponential(3);	"1.235e+5"
				n.toPrecision(4);	"1.235e+5"
				n.toPrecision(7);	"123456.8"
				n.toPrecision(10);	"123456.7890"

				The parseInt() and parseFloat() functions (these are global functions, not methods of any class) aremore flexible. parseInt() parses only integers, while parseFloat() parses both integers and floating-point numbers. If a string begins with “0x” or “0X”, parseInt() interprets it as a hexadecimal number. 

				Both parseInt() and parseFloat() skip leading white-space, parse as many numeric characters as they can, and ignore anything that follows.If the first nonspace character is not part of a valid numeric literal, they return NaN:

				parseInt("3 blind mice")		//3
				parseFloat(" 3.14 meters")		//3.14
				parseInt("-12.34")				//-12
				parseInt("0xFF")				//255
				parseInt("0xff")				//255
				parseInt("-0XFF")				//-255
				parseFloat(".1")				//0.1				
				parseInt("0.1")					//0			
				parseInt(".1")					//NaN: integers can't start with "."
				parseFloat("$72.47");			//NaN: numbers can't start with "$"
				
				
				parseInt() accepts an optional second argument specifying the radix (base) of the
				number to be parsed. Legal values are between 2 and 36. For example:

				parseInt("11", 2);				//3 (1*2 + 1)
				parseInt("ff", 16);				//255 (15*16 + 15)
				parseInt("zz", 36);				//1295 (35*36 + 35)
				parseInt("077", 8);				//63 (7*8 + 7)
				parseInt("077", 10);			//77 (7*10 + 7)

		Object to Primitive Conversions
			The toString()
				method of the Array class, for example, converts each array element to a string and
				joins the resulting strings together with commas in between. The toString() method
				of the Function class returns an implementation-defined representation of a function.
				In practice, implementations usually convert user-defined functions to strings of Java-
				Script source code. The Date class defines a toString() method that returns a human-
				readable (and JavaScript-parsable) date and time string. The RegExp class defines a
				toString() method that converts RegExp objects to a string that looks like a RegExp

			
				[1,2,3].toString()					//"1,2,3"
				
				(function(x) { f(x); }).toString() 	// "function(x) {\n
														f(x);\n}"
													
				/\d+/g.toString()					//"/\\d+/g"

				new Date(2010,0,1).toString() 		//Jan 01 2010 00:00:00 GMT-0800 (PST)"
			valueOf()
				The other object conversion function is called valueOf() . The job of this method is lesswell-defined: it is supposed to convert an object to a primitive value that represents the object, if any such primitive value exists.

	3.10 Function Scope and Hoisting
		JavaScript’s function scope means that all variables declared within a function are visi-
		ble throughout the body of the function. Curiously, this means that variables are even
		visible before they are declared. This feature of JavaScript is informally known as hoist-
		ing:

		Variables As Properties
			When you declare a global JavaScript variable, what you are actually doing is defining
			a property of the global object (§3.5). If you use var to declare the variable, the property
			that is created is nonconfigurable (see §6.7), which means that it cannot be deleted
			with the delete operator.

			var truevar = 1;		//A properly declared global variable, nondeletable.
			fakevar = 2;			//Creates a deletable property of the global object.
			this.fakevar2 = 3;		//This does the same thing.
			delete truevar			//false: variable not deleted
			delete fakevar 			//true: variable deleted
			delete this.fakevar2 	//true: variable deleted

		The Scope Chain
			the scope chain consists of two objects. The first is the object that defines the function’s
			parameters and local variables, and the second is the global object.

Expressions and Operators
	An expression is a phrase of JavaScript that a JavaScript interpreter can evaluate to
	produce a value.

	4.1 Primary Expressions
		Primary expressions in JavaScript are constant or literal values, certain language keywords, and variable reference.

		Literals are constant values that are embedded directly in your program.
			1.23		// A number literal
			"hello"		// A string literal
			/pattern/	// A regular expression literal

		Some of JavaScript’s reserved words are primary expressions:
			true 		// Evalutes to the boolean true value
			false 		// Evaluates to the boolean false value
			null 		// Evaluates to the null value
			this 		// Evaluates to the "current" object

		the third type of primary expression is the bare variable reference:
			i 			// Evaluates to the value of the variable i.
			sum 		// Evaluates to the value of the variable sum.
			undefined	// undefined is a global variable, not a keyword like null.

	4.4 Property Access Expressions
		JavaScript defines two syntaxes for property access:
			expression . identifier
			expression [ expression ]

		With either type of property access expression, the expression before the . or [ is first
		evaluated. If the value is null or undefined , the expression throws a TypeError, since
		these are the two JavaScript values that cannot have properties.

		f(0) // f is the function expression; 0 is the argument expression.

	4.6 Object Creation Expressions
		new Object()
		new Point(2,3)

		new Object
		new Date

		When an object creation expression is evaluated, JavaScript first creates a new empty
		object, just like the one created by the object initializer {} . Next, it invokes the specified
		function with the specified arguments, passing the new object as the value of the
		this keyword.

		If a constructor does return an object value, that value becomes the value of the object
		creation expression and the newly created object is discarded.

	4.7 Operator Overview
		Lvalues
			lvalue is a historical term that means “an
			expression that can legally appear on the left side of an assignment expression.” In
			JavaScript, variables, properties of objects, and elements of arrays are lvalues.

		Operator Side Effects
			The delete operator also has side effects: deleting a property is like (but not the same as) assigning undefined to the property

	4.12 Evaluation Expressions
		JavaScript has the ability to interpret strings of Java-
		Script source code, evaluating them to produce a value. JavaScript does this with the
		global function eval() :

		eval("3+2")		//  5

		eval()
			eval() expects one argument. If you pass any value other than a string, it simply returns
			that value. If you pass a string, it attempts to parse the string as JavaScript code, throw-
			ing a SyntaxError if it fails. If it successfully parses the string, then it evaluates the code	and returns the value of the last expression or statement in the string or undefined if
			the last expression or statement had no value.

			The key thing about eval() (when invoked like this) is that it uses the variable envi-
			ronment of the code that calls it. That is, it looks up the values of variables and defines
			new variables and functions in the same way that local code does. If a function defines
			a local variable x and then calls eval("x") , it will obtain the value of the local variable.
			If it calls eval("x=1") , it changes the value of the local variable. And if the function calls
			eval("var y = 3;") , it has declared a new local variable y . Similarly a function can
			declare a local function with code like this:

			eval("function f() { return x+1; }");

			If the eval() function was invoked by any name other than “eval”, it was allowed to throw an EvalError.

		Global eval()
			Direct calls to eval() use the variable environment of the calling context. Any other call—an indirect call—uses the global object as its variable environment and cannot read, write,or define local variables or functions.


			Before IE9, IE differs from other browsers: it does not do a global eval when eval() is
			invoked by a different name. (It doesn’t throw an EvalError either: it simply does a local
			eval.) But IE does define a global function named execScript() that executes its string
			argument as if it were a top-level script. (Unlike eval() , however, execScript() always
			returns null .)

		Strict eval()
			“use strict” directive, then eval() does a local eval with a private variable environment.
			This means that in strict mode, evaluated code can query and set local variables, but it
			cannot define new variables or functions in the local scope.

			Furthermore, strict mode makes eval() even more operator-like by effectively making
			“eval” into a reserved word. You are not allowed to overwrite the eval() function with
			a new value. And you are not allowed to declare a variable, function, function param-
			eter, or catch block parameter with the name “eval”.

	4.13  Miscellaneous Operators
		typeof Operator
			x 								typeof x
			-------------------------------------------
			undefined 						"undefined"
			null 							"object"
			true or false 					"boolean"
			any number or NaN 				"number"
			any string 						"string"		
			any function 					"function"
			any nonfunction native object 	"object"
			any host object 				An implementation-defined string, 
											but not “undefined”, “boolean”,
											“number”, or “string”.

		The delete Operator
			delete is a unary operator that attempts to delete the object property or array element
			specified as its operand.

			var o = { x: 1, y: 2}; 	// Start with an object
			delete o.x;				// Delete one of its properties
			"x" in o				// false: the property does not exist anymore
			var a = [1,2,3];		// Start with an array
			delete a[2];			// Delete the last element of the array
			a.length				// => 2: array only has two elements now

			
			
			
			



			
			
			


		
		
		
				
				
				
			
			
						
			
			


			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
		
		
		
		

		




	



























Function
	All functions return a value in JavaScript. In the absence of an explicit return statement, a function returns undefined.

Immediately Executing Function
	You can execute a function immediately after you define it. Simply wrap the function in parentheses () and invoke it,

	(function foo() {
		console.log('foo was executed!');
	})();

	The reason for having an immediately executing function is to create a new variable scope. An if, else, or while does not create a new variable scope in JavaScript.

Anonymous Function
	A function without a name is called an anonymous function. In JavaScript, you can assign a function to a variable.
	If you are going to use a function as a variable, you don’t need to name the function.

	var foo1 = function namedFunction() { 
		// no use of name, just wasted characters
		console.log('foo1');
	}
	foo1(); // foo1
 
	var foo2 = function () {
		// no function name given i.e. anonymous function
		console.log('foo2');
	}
	foo2(); // foo2

first-class functions
	A programming language is said to have first-class functions if a function can be treated the same way as any other
	variable in the language. JavaScript has first-class functions.

Higher-Order Functions
	Functions that take functions as arguments are called higher-order functions.

	setTimeout(function () {
		console.log('2000 milliseconds have passed since this demo started');
	}, 2000);

Closures
	Whenever we have a function defined inside another function, the inner function has access to the variables declared
	in the outer function.




Module In Node.js
	File-Based Module System
		• Each file is its own module.
		• Each file has access to the current module definition using the module variable.
		• The export of the current module is determined by the module.exports variable.
		• To import a module, use the globally available require function.
	Core Module
		path,fs,os,util,

	external node_modules

node.js module system (CommonJS) Approach
	var foo = require('./foo');
	var bar = require('./bar');
	// continue code here

Browser module system (AMD-async module defination) Approach
	define(['./foo', './bar'], function(foo, bar){
		// continue code here
	});
	third party RequireJS needed

Globals
	true globals (shared between all modules) 
		ex: require,console__dirname__filenameprocessBufferglobal

	local globals (variables specific to the current module).
		ex: module and exports.


A few points to keep in mind when working with async functions based
on callbacks are the following:
1. Never call the callback twice.
2. Never throw an error.

client-side XHRs (XMLHttpRequest)
XMLHttpRequest (XHR) is a global class available in all modern browsers that allows you to make HTTP requests
using JavaScript. The name is XMLHttpRequest to ensure that all browsers follow the same name for this class. The name
has XML in it because that was the original intended data format for making HTTP requests, but it is not relevant anymore
as it can be used to make HTTP requests in any format. In fact, most people just use the JSON format now.

The View handles the visual part,
taking care of user interaction. The Controller responds to system and user events,
commanding the Model and View to change appropriately. The Model handles data
manipulation, responding to requests for information or changing its state according
to the Controller's instructions.

thread & process
http://www.cs.ucsb.edu/~rich/class/cs170/notes/IntroThreads/


websocket
https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications

http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-node-js

"It is impossible for a distributed computer system to simultaneously provide all three of the
following guarantees: Consistency, Availability, and Partition tolerance."

mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092